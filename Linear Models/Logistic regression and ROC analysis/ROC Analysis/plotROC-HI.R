
###  Example 2    Randomly generated continuous data:
###  ---------   
###	
###  rocPlot(rep(c(0,1),c(80,80)),c(rnorm(80),1.6+rnorm(80)))
###	

rocPlot <- function(group,                #group label
                    ordinal,              #ordinal values
                    nbreaks=15,           #nbreaks used in histogram
                    minAtom.plot=25,      #parameter for superimposing points on plots 
                    xtxt="Measurements",  #x-axis label
                    plots.one.page=TRUE,  #put all plots on one page?
                    area.only=FALSE,      #compute area; skip everything else
                    ...) {
  
  group.uniq <- sort(unique(group))
  neg <- ordinal[group==group.uniq[1]]
  pos <- ordinal[group==group.uniq[2]]
  n.neg <- length(neg)
  n.pos <- length(pos)
  range.data <- range(neg, pos)
  
  ###   Find all distinct atoms generated by pos and neg test values
  
  atoms <- unique(sort(c(neg,pos)))
  atoms.neg <- unique(sort(neg))
  atoms.pos <- unique(sort(pos))
  n.atoms <- length(atoms)
  
  ###   (1)  Compute tp and fp values for each distinct atom
  ###   (2)  Compute CDF's
  
  tp=apply(cbind(1:n.atoms),1,function(i){sum(pos > atoms[i])/n.pos})
  fp=apply(cbind(1:n.atoms),1,function(i){sum(neg > atoms[i])/n.neg})
  cdf.neg=apply(cbind(1:length(atoms.neg)),1,function(i){sum(neg <= atoms.neg[i])/n.neg})
  cdf.pos=apply(cbind(1:length(atoms.pos)),1,function(i){sum(pos <= atoms.pos[i])/n.pos})
  
  ###   Add end values for tp, fp values and CDF's
  
  tp <- c(1,tp)
  fp <- c(1,fp)	
  delta <- (range.data[2]-range.data[1])/20
  atoms.neg <- c(atoms[1]-delta,atoms.neg,atoms[n.atoms]+delta)
  atoms.pos <- c(atoms[1]-delta,atoms.pos,atoms[n.atoms]+delta)
  cdf.neg <- c(0,cdf.neg,1)
  cdf.pos <- c(0,cdf.pos,1)          
  
  ###   (1) Calculate area and partial area under curve using Wilcoxon U-statistic
  ###   (2) Estimate standard error for ROC area
  
  tp.mean <- (tp[1:n.atoms] + tp[2:(n.atoms+1)])/2
  fp.diff <- -diff(fp)
  area.U <- sum(fp.diff*tp.mean)
  PUC.U <- cumsum(fp.diff*tp.mean)
  area.S <- sqrt((area.U*(1 - area.U)+(n.pos - 1)*(area.U/(2 - area.U) 
                                                   - area.U^2) + (n.neg - 1)*((2*area.U^2)/(1 + area.U) 
                                                                              - area.U^2))/(n.pos*n.neg))
  
  if (!area.only) {         
    ###   (1) ROC curve

    ###   (3) CDF for test values
    ###   (2) Stacked histogram of positive and negative test values.
    
    if (plots.one.page) {
      par(mfrow=c(1,3))
      main <- c("ROC Curve","Stacked Histograms","CDF Plot")
    }
    else {
      par(mfrow=c(1,1))
      main <- c("","","")
    }
    if(n.atoms>=minAtom.plot){
      plot(fp,tp,type="l",xlim=c(0.0,1.0),            
           ylim=c(0.0,1.0),xlab="1-Specificity",
           ylab="Sensitivity",main=main[1])
 #     text(0.7,0.1,paste('Area=',format(round(area.U,3)),
  #                       '+/-',format(round(area.S,3))))
    }
    else{
      plot(fp,tp,type="b",xlim=c(0.0,1.0),
           ylim=c(0.0,1.0),xlab="1-Specificity",
           ylab="Sensitivity",main=main[1])
 #     text(0.7,0.1,paste('Area=',format(round(area.U,3)),
  #                       '+/-',format(round(area.S,3))))
    }
    abline(0,1,lty=3)
    
 ###  Mimic a histogram using barplot
 
 nbreaks <- min(nbreaks,max(n.atoms,range.data[2]-range.data[1]))    
 data.bks <- seq(range.data[1]-.001,range.data[2]+.001,
                 length=nbreaks+2)
 temp.neg <- hist(neg,breaks=data.bks,plot = FALSE)
 pct.neg <- temp.neg$count
 temp.pos <- hist(pos,breaks=data.bks,plot = FALSE)
 pct.pos <- temp.pos$count
 barplot(rbind(pct.pos,pct.neg),
         beside = FALSE,
         yaxt="n",srt=90,
         space=0,col=c(2,4),
         xlab=xtxt,
         ylab="Counts",
         main=main[2])
 junk.fit <- lm(seq(0.5, length(data.bks), by=1) ~ data.bks)
 pretty.x <- coef(junk.fit) %*% t(cbind(1,pretty(data.bks,10)))
 nice.probs <- pretty(range(c(pct.pos+pct.neg)))
 axis(1,at=pretty.x,labels=pretty(data.bks,10))
 axis(2,at=nice.probs,lab=abs(nice.probs))
 
 
    if(n.atoms>=minAtom.plot){
      plot(atoms.neg,cdf.neg,type="s",lty=1,col=4,
           xlim=range(atoms.neg,atoms.pos),
           ylim=range(cdf.neg,cdf.pos),
           xlab=xtxt,
           ylab="Cumulative Probabilities",
           main=main[3])
      par(new = TRUE)
      plot(atoms.pos,cdf.pos,type="s",lty=2,col=2,
           xlab="",ylab="")
    }
    else{
      plot(atoms.neg,cdf.neg,type="s",lty=1,col=4,
           xlim=range(atoms.neg,atoms.pos),
           ylim=range(cdf.neg,cdf.pos),
           xlab=xtxt,ylab="Cumulative Probabilities",
           main=main[3])
      rug(atoms)
      par(new = TRUE)
      points(atoms.neg,cdf.neg,pch="x")
      par(new=T)
      plot(atoms.pos,cdf.pos,type="s",lty=2,col=2,
           xlab="",ylab="")
      par(new = TRUE)
      points(atoms.pos,cdf.pos,type="p",pch="o")
    }
    
 
    ### Output results
    
    cat("-----------------------------------------------------------","\n")
    cat("ROC Analysis","\n")
    cat("------------","\n")
    cat("sample size                         :", n.neg+n.pos,"\n")
    cat("no. observations from group 1       :", n.neg,"\n")
    cat("no. observations from group 2       :", n.pos,"\n")
    cat("area under the curve                :",
        paste(round(area.U,3)), '+/-',round(area.S,3))
    cat("\n")
  }
  else {
    return(list(
      area.U=area.U,        #area under curve
      area.S=area.S,        #standard error for area under curve
      tp=tp,                #true positive rate
      fp=fp,                #false positive rate
      unique.values=atoms,  #unique test values
      n.neg=n.neg,          #number of negative values
      n.pos=n.pos           #number of positive values               
    ))
  }          
  
}

